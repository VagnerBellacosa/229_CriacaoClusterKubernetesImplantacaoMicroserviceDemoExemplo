[Avançar para o conteúdo principal](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd-kubernetes#main)



[Learn](https://learn.microsoft.com/pt-br/)[Documentação](https://learn.microsoft.com/pt-br/docs/)[Treinamento](https://learn.microsoft.com/pt-br/training/)[Certificações](https://learn.microsoft.com/pt-br/certifications/)[Q&A](https://learn.microsoft.com/pt-br/answers/products/)[Exemplos de Código](https://learn.microsoft.com/pt-br/samples/browse/)[Avaliações](https://learn.microsoft.com/pt-br/assessments/)[programa](https://learn.microsoft.com/pt-br/shows/)[Eventos](https://learn.microsoft.com/pt-br/events/)



[Entrar](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd-kubernetes#)

[Azure](https://learn.microsoft.com/pt-br/azure/)

Documentação do produtoArquiteturaAprender sobre o AzureDesenvolverRecursos



1. [Portal](https://portal.azure.com/)
2. [Conta gratuita](https://azure.microsoft.com/free/)

Ignorar alerta

 Algumas partes deste tópico podem ter sido traduzidas automaticamente. É possível sugerir uma tradução melhor ao clicar no botão Editar. Consulte o [guia de contribuição](https://learn.microsoft.com/en-us/contribute/) para instruções.

Pesquisar

- [Centro de Arquitetura do Azure](https://learn.microsoft.com/pt-br/azure/architecture/)
- [Procurar todas as arquiteturas](https://learn.microsoft.com/pt-br/azure/architecture/browse/)
- [Ícones de arquitetura](https://learn.microsoft.com/pt-br/azure/architecture/icons/)
- [Novidades](https://learn.microsoft.com/pt-br/azure/architecture/changelog)
- Zonas de destino
- Conceitos básicos da arquitetura de aplicativos
- Padrões de design
- [Estrutura Bem Projetada do Microsoft Azure](https://learn.microsoft.com/pt-br/azure/architecture/framework)
- Soluções do setor com o Azure
  - [Visão geral](https://learn.microsoft.com/pt-br/azure/architecture/industries/overview)
  - Varejo
  - Serviços Financeiros
  - Serviços de saúde
  - Governo
  - Produção
  - Energia e Ambiente
  - Telecomunicações
  - Automotivo, Mobilidade e Transporte
  - Educação
  - Sem fins lucrativos
  - Verticais adicionais
  - [Soluções específicas do setor de IoT](https://learn.microsoft.com/pt-br/azure/architecture/reference-architectures/iot/industry-iot-hub-page)
- Categorias do Azure
  - IA + Machine Learning
  - Análise
  - Blockchain + Computação multipartidária
  - Computação + HPC
  - Contêineres
  - Bancos de dados
  - DataOps
  - Opções do desenvolvedor
    - Microsserviços
      - [Introdução](https://learn.microsoft.com/pt-br/azure/architecture/microservices/)
      - Guides
        - [Avaliação e preparação de microsserviços](https://learn.microsoft.com/pt-br/azure/architecture/guide/technology-choices/microservices-assessment)
        - [Comparar opções de hospedagem de aplicativo Java](https://learn.microsoft.com/pt-br/azure/architecture/guide/technology-choices/service-for-java-comparison)
        - Modelagem de domínio para microserviços
        - Projetar uma arquitetura de microsserviços
        - Operar microsserviços na produção
          - [Monitorar microsserviços no AKS](https://learn.microsoft.com/pt-br/azure/architecture/microservices/logging-monitoring)
          - [CI/CD para microsserviços](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd)
          - [CI/CD para microsserviços em Kubernetes](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd-kubernetes)
        - Migrar para uma arquitetura de microsserviços
        - Microsserviços do .NET
      - Arquiteturas
    - Aplicativos sem servidor
  - DevOps
  - Híbrido + multinuvem
  - Identidade
  - Integração
  - Internet das coisas
  - Mainframe + midrange
  - Gerenciamento + governança
  - Mídia
  - Migração
  - Realidade Misturada
  - Dispositivos móveis
  - Rede
  - Oracle
  - SAP
  - Segurança
  - Armazenamento
  - Área de Trabalho Virtual
  - Web
- [Cloud Adoption Framework](https://learn.microsoft.com/pt-br/azure/cloud-adoption-framework)

Baixar PDF

[Learn](https://learn.microsoft.com/pt-br/) [Azure](https://learn.microsoft.com/pt-br/azure) [Arquitetura](https://learn.microsoft.com/pt-br/azure/architecture) [Microsserviços](https://learn.microsoft.com/pt-br/azure/architecture/microservices) 

[Ler em inglês](https://learn.microsoft.com/en-us/azure/architecture/microservices/ci-cd-kubernetes)Salvar

<details class="popover popover-right" id="article-header-page-actions-overflow" style="box-sizing: inherit; outline-color: inherit; display: inline-block; position: relative;"><summary class="justify-content-flex-start button button-clear button-sm button-primary" aria-label="Mais ações" style="box-sizing: inherit; outline-color: inherit; display: inline-flex; cursor: pointer; min-height: 2.25em; appearance: none; box-shadow: none; vertical-align: top; border: 1px solid rgba(0, 0, 0, 0); border-radius: 0.125rem; justify-content: center; align-items: center; padding-block: calc(0.375em - 1px); padding-inline: 0.75em; font-size: 0.875rem; line-height: 1.5; position: relative; user-select: none; background-color: rgba(0, 0, 0, 0); color: var(--theme-primary-base); text-align: center; font-weight: 600; text-decoration: none; list-style: none;"><span class="icon" aria-hidden="true" style="box-sizing: inherit; outline-color: inherit; justify-content: center; align-items: center; display: inline-flex; width: 1em; height: 1em; margin: 0px;"><span class="docon docon-more-vertical" style="box-sizing: inherit; outline-color: inherit; font-family: docons; font-size: inherit; speak: none; font-variant: normal; text-transform: none; text-align: center; direction: ltr; -webkit-font-smoothing: antialiased; font-style: normal; font-weight: 400; line-height: 16px; display: inline-block;"></span></span></summary><div class="popover-content padding-none" style="box-sizing: inherit; outline-color: inherit; padding: 1rem; width: 224px; border: 1px solid var(--theme-border); background-color: var(--theme-body-background); box-shadow: 0 6.4px 14.4px 0 var(--theme-box-shadow-medium),0 1.2px 3.6px 0 var(--theme-box-shadow-light); z-index: 1060; border-radius: 0.25rem; margin-block-start: 0.5rem; position: absolute; inset-inline-end: 0px;"><button class="button button-block button-clear button-sm justify-content-flex-start has-inner-focus" title="Imprimir" type="button" aria-label="Imprimir" data-bi-name="print" data-page-action-item="overflow-all" data-popover-close="" data-print-page="" data-check-hidden="true" style="box-sizing: inherit; outline-color: inherit; margin: 0px; font-family: inherit; font-size: 0.875rem; line-height: 1.5; overflow: visible; text-transform: none; appearance: button; color: currentcolor; background-color: rgba(0, 0, 0, 0); cursor: pointer; min-height: 2.25em; box-shadow: none; vertical-align: top; border: 1px solid rgba(0, 0, 0, 0); border-radius: 0.125rem; justify-content: center; align-items: center; padding-block: calc(0.375em - 1px); padding-inline: 0.75em; display: flex; position: relative; user-select: none; text-align: center; font-weight: 600; text-decoration: none; width: 222px;"><span class="icon" aria-hidden="true" style="box-sizing: inherit; outline-color: inherit; justify-content: center; align-items: center; display: inline-flex; width: 1em; height: 1em; margin-inline-end: 0.375em;"><span class="docon docon-print" style="box-sizing: inherit; outline-color: inherit; font-family: docons; font-size: inherit; speak: none; font-variant: normal; text-transform: none; text-align: center; direction: ltr; -webkit-font-smoothing: antialiased; font-style: normal; font-weight: 400; line-height: 16px; display: inline-block;"></span></span><span style="box-sizing: inherit; outline-color: inherit;"></span></button><div aria-hidden="true" class="margin-none border-top" data-page-action-item="overflow-all" style="box-sizing: inherit; outline-color: inherit; border-block-start: 1px solid var(--theme-border) !important; margin: 0px !important;"></div><a class="button button-clear button-sm has-inner-focus button-block text-decoration-none justify-content-flex-start share-twitter" data-bi-name="twitter" data-page-action-item="overflow-all" href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Flearn.microsoft.com%2Fpt-br%2Fazure%2Farchitecture%2Fmicroservices%2Fci-cd-kubernetes%3FWT.mc_id%3Dtwitter&amp;text=Pipeline%20de%20CI%2FCD%20de%20microsservi%C3%A7os%20no%20Kubernetes%20com%20o%20Azure%20DevOps%20e%20o%20Helm%20-%20Azure%20Architecture%20Center%20%7C%20Microsoft%20Learn&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Flearn.microsoft.com%2Fpt-br%2Fazure%2Farchitecture%2Fmicroservices%2Fci-cd-kubernetes%3FWT.mc_id%3Dtwitter" style="box-sizing: inherit; outline-color: inherit; color: currentcolor; cursor: pointer; overflow-wrap: break-word; text-decoration: none; background-color: rgba(0, 0, 0, 0); outline-style: initial; outline-width: 0px; min-height: 2.25em; appearance: none; box-shadow: none; vertical-align: top; border: 1px solid rgba(0, 0, 0, 0); border-radius: 0.125rem; justify-content: center; align-items: center; padding-block: calc(0.375em - 1px); padding-inline: 0.75em; font-size: 0.875rem; line-height: 1.5; display: flex; position: relative; user-select: none; text-align: center; font-weight: 600; width: 222px;"><span class="icon" aria-hidden="true" style="box-sizing: inherit; outline-color: inherit; justify-content: center; align-items: center; display: inline-flex; width: 1em; height: 1em; margin-inline-end: 0.375em;"><span class="docon docon-brand-twitter" style="box-sizing: inherit; outline-color: inherit; font-family: docons; font-size: inherit; speak: none; font-variant: normal; text-transform: none; text-align: center; direction: ltr; -webkit-font-smoothing: antialiased; font-style: normal; font-weight: 400; line-height: 16px; display: inline-block;"></span></span><span style="box-sizing: inherit; outline-color: inherit;"></span></a><a class="button button-clear button-sm has-inner-focus button-block text-decoration-none justify-content-flex-start share-linkedin" data-bi-name="linkedin" data-page-action-item="overflow-all" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Flearn.microsoft.com%2Fpt-br%2Fazure%2Farchitecture%2Fmicroservices%2Fci-cd-kubernetes%3FWT.mc_id%3Dlinkedin" style="box-sizing: inherit; outline-color: inherit; color: currentcolor; cursor: pointer; overflow-wrap: break-word; text-decoration: none; background-color: rgba(0, 0, 0, 0); outline-style: initial; outline-width: 0px; min-height: 2.25em; appearance: none; box-shadow: none; vertical-align: top; border: 1px solid rgba(0, 0, 0, 0); border-radius: 0.125rem; justify-content: center; align-items: center; padding-block: calc(0.375em - 1px); padding-inline: 0.75em; font-size: 0.875rem; line-height: 1.5; display: flex; position: relative; user-select: none; text-align: center; font-weight: 600; width: 222px;"><span class="icon" aria-hidden="true" style="box-sizing: inherit; outline-color: inherit; justify-content: center; align-items: center; display: inline-flex; width: 1em; height: 1em; margin-inline-end: 0.375em;"><span class="docon docon-brand-linkedin" style="box-sizing: inherit; outline-color: inherit; font-family: docons; font-size: inherit; speak: none; font-variant: normal; text-transform: none; text-align: center; direction: ltr; -webkit-font-smoothing: antialiased; font-style: normal; font-weight: 400; line-height: 16px; display: inline-block;"></span></span><span style="box-sizing: inherit; outline-color: inherit;"></span></a><a class="button button-clear button-sm button-block has-inner-focus text-decoration-none justify-content-flex-start share-facebook" data-bi-name="facebook" data-page-action-item="overflow-all" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Flearn.microsoft.com%2Fpt-br%2Fazure%2Farchitecture%2Fmicroservices%2Fci-cd-kubernetes%3FWT.mc_id%3Dfacebook" style="box-sizing: inherit; outline-color: inherit; color: currentcolor; cursor: pointer; overflow-wrap: break-word; text-decoration: none; background-color: rgba(0, 0, 0, 0); outline-style: initial; outline-width: 0px; min-height: 2.25em; appearance: none; box-shadow: none; vertical-align: top; border: 1px solid rgba(0, 0, 0, 0); border-radius: 0.125rem; justify-content: center; align-items: center; padding-block: calc(0.375em - 1px); padding-inline: 0.75em; font-size: 0.875rem; line-height: 1.5; display: flex; position: relative; user-select: none; text-align: center; font-weight: 600; width: 222px;"><span class="icon" aria-hidden="true" style="box-sizing: inherit; outline-color: inherit; justify-content: center; align-items: center; display: inline-flex; width: 1em; height: 1em; margin-inline-end: 0.375em;"><span class="docon docon-brand-facebook" style="box-sizing: inherit; outline-color: inherit; font-family: docons; font-size: inherit; speak: none; font-variant: normal; text-transform: none; text-align: center; direction: ltr; -webkit-font-smoothing: antialiased; font-style: normal; font-weight: 400; line-height: 16px; display: inline-block;"></span></span><span style="box-sizing: inherit; outline-color: inherit;"></span></a><a class="button button-clear button-sm button-block has-inner-focus text-decoration-none justify-content-flex-start share-email" data-bi-name="email" data-page-action-item="overflow-all" href="mailto:?subject=%5BArtigo%20compartilhado%5D%20Pipeline%20de%20CI%2FCD%20de%20microsservi%C3%A7os%20no%20Kubernetes%20com%20o%20Azure%20DevOps%20e%20o%20Helm%20-%20Azure%20Architecture%20Center%20%7C%20Microsoft%20Learn&amp;body=Pipeline%20de%20CI%2FCD%20de%20microsservi%C3%A7os%20no%20Kubernetes%20com%20o%20Azure%20DevOps%20e%20o%20Helm%20-%20Azure%20Architecture%20Center%20%7C%20Microsoft%20Learn%0A%0Ahttps%3A%2F%2Flearn.microsoft.com%2Fpt-br%2Fazure%2Farchitecture%2Fmicroservices%2Fci-cd-kubernetes%3FWT.mc_id%3Demail" style="box-sizing: inherit; outline-color: inherit; color: currentcolor; cursor: pointer; overflow-wrap: break-word; text-decoration: none; background-color: rgba(0, 0, 0, 0); outline-style: initial; outline-width: 0px; min-height: 2.25em; appearance: none; box-shadow: none; vertical-align: top; border: 1px solid rgba(0, 0, 0, 0); border-radius: 0.125rem; justify-content: center; align-items: center; padding-block: calc(0.375em - 1px); padding-inline: 0.75em; font-size: 0.875rem; line-height: 1.5; display: flex; position: relative; user-select: none; text-align: center; font-weight: 600; width: 222px;"><span class="icon" aria-hidden="true" style="box-sizing: inherit; outline-color: inherit; justify-content: center; align-items: center; display: inline-flex; width: 1em; height: 1em; margin-inline-end: 0.375em;"><span class="docon docon-mail-message-fill" style="box-sizing: inherit; outline-color: inherit; font-family: docons; font-size: inherit; speak: none; font-variant: normal; text-transform: none; text-align: center; direction: ltr; -webkit-font-smoothing: antialiased; font-style: normal; font-weight: 400; line-height: 16px; display: inline-block;"></span></span><span style="box-sizing: inherit; outline-color: inherit;"></span></a></div></details>

# Criar um pipeline de CI/CD para microsserviços no Kubernetes com o Azure DevOps e o Helm

Serviço de Kubernetes

Registro de Contêiner

Azure DevOps

Pode ser desafiador criar um processo de CI/CD (integração contínua/entrega contínua) confiável para uma arquitetura de microsserviços. As equipes individuais devem ser capazes de liberar serviços de forma rápida e confiável, sem interromper outras equipes ou desestabilizar o aplicativo como um todo.

Este artigo descreve um exemplo de pipeline de CI/CD para implantar microsserviços no AKS (Serviço de Kubernetes do Azure). Cada equipe e projeto são diferentes, portanto, não leve este artigo como um conjunto de regras rígidas e rápidas. Em vez disso, ele deve ser um ponto de partida para criar seu próprio processo de CI/CD.

As metas de um pipeline de CI/CD para microsserviços hospedados no Kubernetes podem ser resumidas da seguinte maneira:

- O Teams pode criar e implantar seus serviços de forma independente.
- As alterações de código que passam pelo processo de CI são implantadas automaticamente em um ambiente semelhante à produção.
- Os portões de qualidade são impostos em cada estágio do pipeline.
- Uma nova versão de um serviço pode ser implantada lado a lado com a versão anterior.

Para obter mais informações em segundo plano, consulte [CI/CD para arquiteturas de microsserviços](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd).

## Suposições

Para fins deste exemplo, aqui estão algumas suposições sobre a equipe de desenvolvimento e a base de código:

- O repositório de código é um monorepo, com pastas organizadas por microsserviço.
- A estratégia de ramificação da equipe se baseia no [desenvolvimento com base em troncos](https://trunkbaseddevelopment.com/).
- A equipe usa [branches de lançamento](https://learn.microsoft.com/pt-br/azure/devops/repos/git/git-branching-guidance) para gerenciar versões. Versões separadas são criadas para cada microsserviço.
- O processo de CI/CD usa o [Azure Pipelines](https://learn.microsoft.com/pt-br/azure/devops/pipelines) para criar, testar e implantar os microsserviços no AKS.
- As imagens de contêiner para cada microsserviço são armazenadas em [Registro de Contêiner do Azure](https://learn.microsoft.com/pt-br/azure/container-registry).
- A equipe usa gráficos do Helm para empacotar cada microsserviço.
- Um modelo de implantação por push é usado, em que o Azure Pipelines e os agentes associados executam implantações conectando-se diretamente ao cluster do AKS.

Essas suposições conduzem muitos dos detalhes específicos do pipeline de CI/CD. No entanto, a abordagem básica descrita aqui será adaptada para outros processos, ferramentas e serviços, como Jenkins ou Docker Hub.

### Alternativas

Veja a seguir alternativas comuns que os clientes podem usar ao escolher uma estratégia de CI/CD com Serviço de Kubernetes do Azure:

- Como alternativa ao uso do Helm como ferramenta de gerenciamento e implantação de [pacotes, o Kustomize](https://kustomize.io/) é uma ferramenta de gerenciamento de configuração nativa do Kubernetes que introduz uma maneira sem modelos de personalizar e parametrizar a configuração do aplicativo.
- Como alternativa ao uso do Azure DevOps para repositórios Git e pipelines, os [Repositórios GitHub podem ser usados](https://docs.github.com/en/repositories) para repositórios Git públicos e privados e [GitHub Actions](https://github.com/features/actions) podem ser usados para pipelines de CI/CD.
- Como alternativa ao uso de um modelo de implantação por push, o gerenciamento da configuração do Kubernetes em grande escala pode ser feito usando [o GitOps (modelo de implantação pull)](https://learn.microsoft.com/pt-br/azure/architecture/example-scenario/gitops-aks/gitops-blueprint-aks), em que um operador kubernetes no cluster sincroniza o estado do cluster, com base na configuração armazenada em um repositório Git.

## Builds de validação

Suponha que um desenvolvedor esteja trabalhando em um microsserviço chamado Serviço de Entrega. Ao desenvolver um novo recurso, o desenvolvedor coloca código em um branch de recursos. Por convenção, os branches de recursos recebem o nome de `feature/*`.

![Fluxo de trabalho de CI/CD](https://learn.microsoft.com/pt-br/azure/architecture/microservices/images/aks-cicd-1.png)

O arquivo de definição de build inclui um gatilho que filtra pelo nome do branch e pelo caminho de origem:

```yaml
trigger:
  batch: true
  branches:
    include:
    # for new release to production: release flow strategy
    - release/delivery/v*
    - refs/release/delivery/v*
    - master
    - feature/delivery/*
    - topic/delivery/*
  paths:
    include:
    - /src/shipping/delivery/
```

Usando essa abordagem, cada equipe pode ter seu próprio pipeline de build. Somente o código que é verificado na `/src/shipping/delivery` pasta dispara um build do Serviço de Entrega. O envio por push de confirmações para um branch que corresponde ao filtro dispara um build de CI. Agora, no fluxo de trabalho, a compilação de CI executa uma verificação mínima no código:

1. Crie o código.
2. Execute os testes de unidade.

O objetivo é manter os tempos de build curtos para que o desenvolvedor possa obter comentários rápidos. Depois que o recurso estiver pronto para mesclar em mestre, o desenvolvedor abrirá uma PR. Essa operação dispara outro build de CI que executa algumas verificações adicionais:

1. Crie o código.
2. Execute os testes de unidade.
3. Crie a imagem do contêiner de runtime.
4. Execute verificações de vulnerabilidade na imagem.

![Diagrama mostrando ci-delivery-full no pipeline build.](https://learn.microsoft.com/pt-br/azure/architecture/microservices/images/aks-cicd-2.png)

 Observação

No Azure DevOps Repos, você pode definir [políticas](https://learn.microsoft.com/pt-br/azure/devops/repos/git/branch-policies) para proteger branches. Por exemplo, a política poderia exigir uma compilação de CI bem-sucedida e a aprovação de uma pessoa pertinente para fazer a mesclagem com o mestre.

## Compilação completa de CI/CD

Em algum momento, a equipe estará pronta para implantar uma nova versão do Serviço de Entrega. O gerenciador de lançamento cria um branch do branch principal com esse padrão de nomenclatura: `release/<microservice name>/<semver>`. Por exemplo, `release/delivery/v1.0.2`.

![Diagrama mostrando ci-delivery completo no pipeline de build e entrega de cd no pipeline de versão.](https://learn.microsoft.com/pt-br/azure/architecture/microservices/images/aks-cicd-3.png)

A criação desse branch dispara um build completo de CI que executa todas as etapas anteriores mais:

1. Envie por push a imagem de contêiner para o Registro de Contêiner do Azure. A imagem é marcada com o número de versão obtido do nome do branch.
2. Execute `helm package` para empacotar o gráfico do Helm para o serviço. O gráfico também é marcado com um número de versão.
3. Envie o pacote do Helm para o Registro de Contêiner.

Supondo que esse build tenha êxito, ele dispara um processo de CD (implantação) usando um [pipeline de lançamento](https://learn.microsoft.com/pt-br/azure/devops/pipelines/release) do Azure Pipelines. Esse pipeline tem as seguintes etapas:

1. Implante o gráfico do Helm em um ambiente de QA.
2. Um aprovador confirma a aprovação antes que o pacote seja movido para a produção. Confira [Controle de implantação de versão usando aprovações](https://learn.microsoft.com/pt-br/azure/devops/pipelines/release/approvals/approvals).
3. Remarca a imagem do Docker para o namespace de produção em Registro de Contêiner do Azure. Por exemplo, se a marca atual for `myrepo.azurecr.io/delivery:v1.0.2`, a marca de produção será `myrepo.azurecr.io/prod/delivery:v1.0.2`.
4. Implante o gráfico do Helm no ambiente de produção.

Mesmo em um monorepo, essas tarefas podem ser definidas como microsserviços individuais para que as equipes possam implantar com alta velocidade. O processo tem algumas etapas manuais: aprovação de PRs, criação de branches de versão e aprovação de implantações no cluster de produção. Estas etapas são manuais; eles podem ser automatizados se a organização preferir.

## Isolamento de ambientes

Você terá vários ambientes em que implantará serviços, incluindo ambientes para desenvolvimento, teste de fumaça, teste de integração, teste de carga e, por fim, produção. Esses ambientes precisam de algum nível de isolamento. No Kubernetes, você pode escolher entre o isolamento físico e o isolamento lógico. Isolamento físico significa implantar em clusters separados. O isolamento lógico usa namespaces e políticas, conforme descrito anteriormente.

Nossa recomendação é criar um cluster de produção dedicado juntamente com um cluster separado para seus ambientes de desenvolvimento/teste. Use o isolamento lógico para separar ambientes dentro do cluster de desenvolvimento/teste. Os serviços implantados no cluster de desenvolvimento/teste nunca devem ter acesso a armazenamentos de dados que contêm dados de negócios.

## Processo de compilação

Quando possível, empacote seu processo de build em um contêiner do Docker. Essa configuração permite que você crie artefatos de código usando o Docker e sem configurar um ambiente de build em cada computador de build. Um processo de build em contêineres facilita a expansão do pipeline de CI adicionando novos agentes de build. Além disso, qualquer desenvolvedor na equipe pode criar o código simplesmente executando o contêiner de build.

Usando builds de vários estágios no Docker, você pode definir o ambiente de build e a imagem de runtime em um único Dockerfile. Por exemplo, aqui está um Dockerfile que cria um aplicativo .NET:

```dockerfile
FROM mcr.microsoft.com/dotnet/core/runtime:3.1 AS base
WORKDIR /app

FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /src/Fabrikam.Workflow.Service

COPY Fabrikam.Workflow.Service/Fabrikam.Workflow.Service.csproj .
RUN dotnet restore Fabrikam.Workflow.Service.csproj

COPY Fabrikam.Workflow.Service/. .
RUN dotnet build Fabrikam.Workflow.Service.csproj -c release -o /app --no-restore

FROM build AS testrunner
WORKDIR /src/tests

COPY Fabrikam.Workflow.Service.Tests/*.csproj .
RUN dotnet restore Fabrikam.Workflow.Service.Tests.csproj

COPY Fabrikam.Workflow.Service.Tests/. .
ENTRYPOINT ["dotnet", "test", "--logger:trx"]

FROM build AS publish
RUN dotnet publish Fabrikam.Workflow.Service.csproj -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "Fabrikam.Workflow.Service.dll"]
```

Este Dockerfile define vários estágios de build. Observe que o estágio nomeado `base` usa o runtime do .NET, enquanto o estágio nomeado `build` usa o SDK completo do .NET. O `build` estágio é usado para criar o projeto .NET. Mas o contêiner de runtime final é criado com base `base`, que contém apenas o runtime e é significativamente menor do que a imagem completa do SDK.

### Criando um executor de teste

Outra boa prática é executar testes de unidade no contêiner. Por exemplo, aqui está parte de um arquivo do Docker que cria um executor de teste:

```dockerfile
FROM build AS testrunner
WORKDIR /src/tests

COPY Fabrikam.Workflow.Service.Tests/*.csproj .
RUN dotnet restore Fabrikam.Workflow.Service.Tests.csproj

COPY Fabrikam.Workflow.Service.Tests/. .
ENTRYPOINT ["dotnet", "test", "--logger:trx"]
```

Um desenvolvedor pode usar esse arquivo do Docker para executar os testes localmente:

```bash
docker build . -t delivery-test:1 --target=testrunner
docker run delivery-test:1
```

O pipeline de CI também deve executar os testes como parte da etapa de verificação de build.

Observe que esse arquivo usa o comando Docker `ENTRYPOINT` para executar os testes, não o comando docker `RUN` .

- Se você usar o `RUN` comando, os testes são executados sempre que você cria a imagem. Ao usar `ENTRYPOINT`, os testes são aceitos. Eles só são executados quando você direciona explicitamente o `testrunner` estágio.
- Um teste com falha não faz com que o comando docker `build` falhe. Dessa forma, você pode distinguir falhas de build de contêiner de falhas de teste.
- Os resultados do teste podem ser salvos em um volume montado.

### Práticas recomendadas do contêiner

Aqui estão algumas outras práticas recomendadas a serem consideradas para contêineres:

- Defina as convenções de toda a organização para marcações de contêiner, controle de versão e convenções de nomenclatura de recursos implantados para o cluster (pods, serviços e assim por diante). Isso pode facilitar o diagnóstico de problemas de implantação.
- Durante o ciclo de desenvolvimento e teste, o processo de CI/CD cria muitas imagens de contêiner. Apenas algumas dessas imagens são candidatas ao lançamento, e apenas alguns desses candidatos serão promovidos à produção. Tenha uma estratégia de controle de versão clara para que você saiba quais imagens estão implantadas atualmente na produção e para ajudar a reverter para uma versão anterior, se necessário.
- Sempre implante marcas de versão de contêiner específicas, não `latest`.
- Use [namespaces](https://learn.microsoft.com/pt-br/azure/container-registry/container-registry-best-practices#repository-namespaces) em Registro de Contêiner do Azure para isolar imagens aprovadas para produção de imagens que ainda estão sendo testadas. Não mova uma imagem para o namespace de produção até que você esteja pronto para implantá-la em produção. Se você combinar essa prática com controle de versão semântico de imagens de contêiner, isso poderá reduzir a chance de acidentalmente implantar uma versão não aprovada para lançamento.
- Siga o princípio do privilégio mínimo executando contêineres como um usuário sem privilégios. No Kubernetes, você pode criar uma política de segurança de pod que impede que contêineres sejam executados como *raiz*. Consulte [Impedir que pods sejam executados com privilégios raiz](https://docs.bitnami.com/kubernetes/how-to/secure-kubernetes-cluster-psp/).

## Gráficos Helm

Considere usar o Helm para gerenciar, criar e implantar serviços. Aqui estão alguns dos recursos do Helm que ajudam com CI/CD:

- Geralmente, um único microsserviço é definido por vários objetos kubernetes. O Helm permite que esses objetos sejam empacotados em um único gráfico do Helm.
- Um gráfico pode ser implantado com um único comando Helm em vez de uma série de comandos kubectl.
- Os gráficos são explicitamente versões. Use o Helm para lançar uma versão, exibir versões e reverter para uma versão anterior. Acompanhar atualizações e revisões, usando controle de versão semântico, além da capacidade de reverter para uma versão anterior.
- Os gráficos do Helm usam modelos para evitar a duplicação de informações, como rótulos e seletores, em muitos arquivos.
- O Helm pode gerenciar dependências entre gráficos.
- Os gráficos podem ser armazenados em um repositório Helm, como Registro de Contêiner do Azure, e integrados ao pipeline de build.

Para obter mais informações sobre como usar o Registro de Contêiner como um repositório do Helm, confira [Usar o Registro de Contêiner do Azure como um repositório do Helm para os gráficos do aplicativo](https://learn.microsoft.com/pt-br/azure/container-registry/container-registry-helm-repos).

Um único microsserviço pode envolver vários arquivos de configuração do Kubernetes. Atualizar um serviço pode significar tocar todos esses arquivos para atualizar seletores, rótulos e marcas de imagem. O Helm os trata como um único pacote chamado gráfico e permite que você atualize facilmente os arquivos YAML usando variáveis. O Helm usa uma linguagem de modelo (com base em modelos go) para permitir que você escreva arquivos de configuração YAML parametrizados.

Por exemplo, aqui está parte de um arquivo YAML que define uma implantação:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "package.fullname" . | replace "." "" }}
  labels:
    app.kubernetes.io/name: {{ include "package.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    kubernetes.io/change-cause: {{ .Values.reason }}

...

  spec:
      containers:
      - name: &package-container_name fabrikam-package
        image: {{ .Values.dockerregistry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        env:
        - name: LOG_LEVEL
          value: {{ .Values.log.level }}
```

Você pode ver que o nome da implantação, os rótulos e a especificação de contêiner usam parâmetros de modelo, que são fornecidos no momento da implantação. Por exemplo, na linha de comando:

```bash
helm install $HELM_CHARTS/package/ \
     --set image.tag=0.1.0 \
     --set image.repository=package \
     --set dockerregistry=$ACR_SERVER \
     --namespace backend \
     --name package-v0.1.0
```

Embora seu pipeline de CI/CD possa instalar um gráfico diretamente no Kubernetes, recomendamos criar um arquivo de gráfico (arquivo.tgz) e enviar o gráfico por push para um repositório helm, como Registro de Contêiner do Azure. Para obter mais informações, consulte [aplicativos baseados no Docker de Pacote nos gráficos do Helm no Azure Pipelines](https://learn.microsoft.com/pt-br/azure/devops/pipelines/tasks/deploy/helm-deploy).

### Revisões

Os gráficos do Helm sempre têm um número de versão, que deve usar controle de [versão semântico](https://semver.org/). Um gráfico também pode ter um `appVersion`. Esse campo é opcional e não precisa estar relacionado à versão do gráfico. Algumas equipes podem querer aplicar versões separadamente das atualizações para os gráficos. Mas uma abordagem mais simples é usar um número de versão, portanto, há uma relação 1:1 entre a versão do gráfico e a versão do aplicativo. Dessa forma, você pode armazenar um gráfico por versão e implantar facilmente a versão desejada:

```bash
helm install <package-chart-name> --version <desiredVersion>
```

Outra boa prática é fornecer uma anotação de causa de alteração no modelo de implantação:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "delivery.fullname" . | replace "." "" }}
  labels:
     ...
  annotations:
    kubernetes.io/change-cause: {{ .Values.reason }}
```

Isso permite exibir o campo de causa de alteração para cada revisão, usando o `kubectl rollout history` comando. No exemplo anterior, a causa da alteração é fornecida como um parâmetro de gráfico do Helm.

```bash
kubectl rollout history deployments/delivery-v010 -n backend
deployment.extensions/delivery-v010
REVISION  CHANGE-CAUSE
1         Initial deployment
```

Você também pode usar o `helm list` comando para exibir o histórico de revisão:

```bash
helm list
NAME            REVISION    UPDATED                     STATUS        CHART            APP VERSION     NAMESPACE
delivery-v0.1.0 1           Sun Apr  7 00:25:30 2020    DEPLOYED      delivery-v0.1.0  v0.1.0          backend
```

## Azure DevOps Pipeline

No Azure Pipelines, os pipelines são divididos em *pipelines de build* e *pipelines de lançamento*. O pipeline de build executa o processo de CI e cria artefatos de build. Para uma arquitetura de microsserviços no Kubernetes, esses artefatos são as imagens de contêiner e os gráficos do Helm que definem cada microsserviço. O pipeline de versão executa esse processo de CD que implanta um microsserviço em um cluster.

Com base no fluxo de CI descrito anteriormente neste artigo, um pipeline de build pode consistir nas seguintes tarefas:

1. Crie o contêiner do executor de teste.

   ```yaml
   - task: Docker@1
     inputs:
       azureSubscriptionEndpoint: $(AzureSubscription)
       azureContainerRegistry: $(AzureContainerRegistry)
       arguments: '--pull --target testrunner'
       dockerFile: $(System.DefaultWorkingDirectory)/$(dockerFileName)
       imageName: '$(imageName)-test'
   ```

2. Execute os testes invocando a execução do Docker no contêiner do executor de teste.

   ```yaml
   - task: Docker@1
     inputs:
       azureSubscriptionEndpoint: $(AzureSubscription)
       azureContainerRegistry: $(AzureContainerRegistry)
       command: 'run'
       containerName: testrunner
       volumes: '$(System.DefaultWorkingDirectory)/TestResults:/app/tests/TestResults'
       imageName: '$(imageName)-test'
       runInBackground: false
   ```

3. Publique os resultados do teste. Consulte [Criar uma imagem](https://learn.microsoft.com/pt-br/azure/devops/pipelines/ecosystems/containers/build-image).

   ```yaml
   - task: PublishTestResults@2
     inputs:
       testResultsFormat: 'VSTest'
       testResultsFiles: 'TestResults/*.trx'
       searchFolder: '$(System.DefaultWorkingDirectory)'
       publishRunAttachments: true
   ```

4. Crie o contêiner de runtime.

   ```yaml
   - task: Docker@1
     inputs:
       azureSubscriptionEndpoint: $(AzureSubscription)
       azureContainerRegistry: $(AzureContainerRegistry)
       dockerFile: $(System.DefaultWorkingDirectory)/$(dockerFileName)
       includeLatestTag: false
       imageName: '$(imageName)'
   ```

5. Envie a imagem do contêiner por push para Registro de Contêiner do Azure (ou outro registro de contêiner).

   ```yaml
   - task: Docker@1
     inputs:
       azureSubscriptionEndpoint: $(AzureSubscription)
       azureContainerRegistry: $(AzureContainerRegistry)
       command: 'Push an image'
       imageName: '$(imageName)'
       includeSourceTags: false
   ```

6. Empacotar o gráfico do Helm.

   ```yaml
   - task: HelmDeploy@0
     inputs:
       command: package
       chartPath: $(chartPath)
       chartVersion: $(Build.SourceBranchName)
       arguments: '--app-version $(Build.SourceBranchName)'
   ```

7. Envie o pacote do Helm por push para Registro de Contêiner do Azure (ou outro repositório Helm).

   ```yaml
   task: AzureCLI@1
     inputs:
       azureSubscription: $(AzureSubscription)
       scriptLocation: inlineScript
       inlineScript: |
       az acr helm push $(System.ArtifactsDirectory)/$(repositoryName)-$(Build.SourceBranchName).tgz --name $(AzureContainerRegistry);
   ```

A saída do pipeline de CI é uma imagem de contêiner pronta para produção e um gráfico do Helm atualizado para o microsserviço. Neste ponto, o pipeline de lançamento pode assumir o comando. Haverá um pipeline de lançamento exclusivo para cada microsserviço. O pipeline de lançamento será configurado para ter uma fonte de gatilho definida para o pipeline de CI que publicou o artefato. Esse pipeline permite que você tenha implantações independentes de cada microsserviço. O pipeline de lançamento executa as seguintes etapas:

- Implante o gráfico do Helm em ambientes de desenvolvimento/QA/preparo. O `Helm upgrade` comando pode ser usado com o `--install` sinalizador para dar suporte à primeira instalação e às atualizações subsequentes.
- Aguarde até que um aprovador aprove ou rejeite a implantação.
- Remarcar a imagem do contêiner para lançamento
- Envie a marca de versão por push para o registro de contêiner.
- Implante o gráfico do Helm no cluster de produção.

Para obter mais informações sobre como criar um pipeline de lançamento, consulte [pipelines de lançamento, versões de rascunho e opções de versão](https://learn.microsoft.com/pt-br/azure/devops/pipelines/release).

O diagrama a seguir mostra o processo de CI/CD de ponta a ponta descrito neste artigo:

![Pipeline de CD/CD](https://learn.microsoft.com/pt-br/azure/architecture/microservices/images/aks-cicd-flow.png)

## Colaboradores

*Esse artigo é mantido pela Microsoft. Ele foi escrito originalmente pelos colaboradores a seguir.*

Autor principal:

- [John Poole](https://www.linkedin.com/in/johnrpoole) | Arquiteto sênior de soluções de nuvem

*Para ver perfis não públicos do LinkedIn, entre no LinkedIn.*

## Próximas etapas

- [Adotar uma estratégia de branch do Git](https://learn.microsoft.com/pt-br/azure/devops/repos/git/git-branching-guidance)
- [O que é o Azure Pipelines?](https://learn.microsoft.com/pt-br/azure/devops/pipelines/get-started/what-is-azure-pipelines)
- [Liberar pipelines, versões de rascunho e opções de versão](https://learn.microsoft.com/pt-br/azure/devops/pipelines/release)
- [Controle de implantação de versão usando aprovações](https://learn.microsoft.com/pt-br/azure/devops/pipelines/release/approvals/approvals)
- [Introdução aos registros de contêiner no Azure](https://learn.microsoft.com/pt-br/azure/container-registry/container-registry-intro)

## Recursos relacionados

- [CI/CD para microsserviços](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd)
- [Monitorar uma arquitetura de microsserviços no SERVIÇO DE KUBERNETES DO AZURE (AKS)](https://learn.microsoft.com/pt-br/azure/architecture/microservices/logging-monitoring)
- [Examinar uma arquitetura de referência que mostra um aplicativo de microsserviços implantado no AKS (Serviço de Kubernetes do Azure)](https://learn.microsoft.com/pt-br/azure/architecture/reference-architectures/containers/aks-microservices/aks-microservices)
- [GitOps para Serviço de Kubernetes do Azure](https://learn.microsoft.com/pt-br/azure/architecture/example-scenario/gitops-aks/gitops-blueprint-aks)

------

## Conteúdo recomendado

- [Criar e implantar aplicativos no AKS usando DevOps e GitOps - Azure Example Scenarios](https://learn.microsoft.com/pt-br/azure/architecture/example-scenario/apps/devops-with-aks?source=recommendations)

  Saiba como criar e implantar aplicativos de contêiner usando Serviço de Kubernetes do Azure, DevOps e GitOps.

- [CI/CD para microsserviços - Azure Architecture Center](https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd?source=recommendations)

  Saiba mais sobre integração contínua e entrega contínua para microsserviços, incluindo desafios e abordagens recomendadas.

- [CI/CD para contêineres - Azure Architecture Center](https://learn.microsoft.com/pt-br/azure/architecture/solution-ideas/articles/cicd-for-containers?source=recommendations)

  Saiba como orquestrar CI/CD de contêineres usando o Kubernetes em Serviço de Kubernetes do Azure, para que você possa obter clusters replicáveis e gerenciáveis de contêineres.

- [Estratégia de implantação canário para implantações do Kubernetes - Azure Pipelines](https://learn.microsoft.com/pt-br/azure/devops/pipelines/ecosystems/kubernetes/canary-demo?source=recommendations)

  Demonstração da execução de implantações canárias em clusters do Kubernetes usando o Azure Pipelines

Mostrar mais

## Comentários

Enviar e exibir comentários de

[Esta página](https://github.com/MicrosoftDocs/architecture-center/issues/new?title=&body= [Insira comentários aqui]  --- %23%23%23%23 Detalhes do documento ⚠ *Não edite esta seção. É necessário para a vinculação de problema do learn.microsoft.com ➟ GitHub.* * ID%3A 57f4d213-3eb1-5b4c-aa67-116e8fa36f7d * Version Independent ID%3A 18199b5a-8f57-6574-c795-7540199ae49a * Content%3A [Pipeline de CI%2FCD de microsserviços no Kubernetes com o Azure DevOps e o Helm - Azure Architecture Center](https%3A%2F%2Flearn.microsoft.com%2Fpt-br%2Fazure%2Farchitecture%2Fmicroservices%2Fci-cd-kubernetes) * Content Source%3A [docs%2Fmicroservices%2Fci-cd-kubernetes.yml](https%3A%2F%2Fgithub.com%2Fmicrosoftdocs%2Farchitecture-center%2Fblob%2Fmain%2Fdocs%2Fmicroservices%2Fci-cd-kubernetes.yml) * Service%3A **architecture-center** * Sub-service%3A **azure-guide** * GitHub Login%3A %40jpocloud * Microsoft Alias%3A **johnpoole**)

[ Exibir todos os comentários da página](https://github.com/MicrosoftDocs/architecture-center/issues?utf8=✓&q="18199b5a-8f57-6574-c795-7540199ae49a"&in=body)

[Português (Brasil)](https://learn.microsoft.com/pt-br/locale?target=https://learn.microsoft.com/pt-br/azure/architecture/microservices/ci-cd-kubernetes)

Tema

- Gerenciar cookies
- [Versões anteriores](https://learn.microsoft.com/pt-br/previous-versions/)
- [Blog](https://techcommunity.microsoft.com/t5/microsoft-learn-blog/bg-p/MicrosoftLearnBlog)
- [Contribuir](https://learn.microsoft.com/pt-br/contribute/)
- [Privacidade](https://go.microsoft.com/fwlink/?LinkId=521839)
- [Termos de Uso](https://learn.microsoft.com/pt-br/legal/termsofuse)
- [Marcas Comerciais](https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx)
- © Microsoft 2023